# -*- coding: utf-8 -*-
# """Bitcoin price prediction.ipynb"
#
# Automatically generated by Colaboratory.
#
# Original file is located at
#     https://colab.research.google.com/drive/1PWuu07ib9U20uVANft4yAbjVPqL06NLD
#
# Данные
# https://drive.google.com/file/d/1tS9xlFQnxFP4HDHe6669qskkkT1GQg6O/view?usp=sharing
#
# Источник
# https://www.cryptodatadownload.com/data/bitfinex/
# """

# Сначала — загрузить файл в колаб
import zipfile
with zipfile.ZipFile("/content/BitFinexData.zip", "r") as zipf:
  zipf.extractall("/content/bitfinex/")

import pandas as pd
bitcoin = pd.read_csv("/content/bitfinex/Bitfinex_BTCUSD_d.csv", skiprows=1)

####
bitcoin.set_index("unix", inplace=True)
bitcoin = bitcoin[::-1]  #  Вернуть строчки в обратном порядке
bitcoin.reset_index(inplace=True)
bitcoin.drop("unix", axis=1, inplace=True)
####

bitcoin.date = pd.to_datetime(bitcoin.date)

bitcoin.head()

bitcoin.describe()

# bitcoin.open, это тоже самое что bitcoin["open"]

bitcoin.open.plot()

import matplotlib.pyplot as plt

plt.plot(bitcoin.date, bitcoin["Volume USD"], label="Volume USD")
plt.legend()  #  Отобразить легенда
plt.show()  #  Отобразить график

plt.plot(bitcoin.date, bitcoin["Volume BTC"], label="Volume BTC")
plt.legend()  #  Отобразить легенда
plt.show()  #  Отобразить график

plt.plot(bitcoin.date, bitcoin.open - bitcoin.close, label="Open - Close")
plt.legend()  #  Отобразить легенда
plt.show()  #  Отобразить график

plt.plot(bitcoin.date, bitcoin.high - bitcoin.low, label="High - Low")
plt.legend()  #  Отобразить легенда
plt.show()  #  Отобразить график

# Feature Enginnering
# Добавляем новые колонки в датасет на основе имеющихся колонок

bitcoin["open_close_diff"] = bitcoin["open"] -  bitcoin["close"]
bitcoin["high_low_diff"] = bitcoin["high"] - bitcoin["low"]
bitcoin["open_to_high"] = bitcoin["open_close_diff"] / bitcoin["high_low_diff"]

bitcoin.head()

bitcoin["high_mean_7d"] = bitcoin["high"].shift(1).rolling(window=7).mean()  #  Средняя цена за 7 дней
bitcoin["max_open_14d"] = bitcoin["open"].shift(1).rolling(window=14).max()
bitcoin["min_close_14d"] = bitcoin["close"].shift(1).rolling(window=14).min()

bitcoin.groupby(bitcoin["date"].dt.weekday)["Volume BTC"].mean().plot(kind="bar")

# ДЗ: добавить колонки по году и месяцу и дню недели
# bitcoin["date"].dt.year
# bitcoin["date"].dt.month

for day in range(1,8):
  bitcoin[f"close_{day}d"] = bitcoin["close"].shift(day)

bitcoin.head(20)

bitcoin.drop("date", axis=1, inplace=True)
bitcoin.drop("symbol", axis=1, inplace=True)
bitcoin["target"] = bitcoin["close"].shift(-1)

bitcoin.dropna(inplace=True) # Удалить строки с NaN

# Разделить данные на "вход" и "выход"
# Задача модели машинного обучения — найти закономерности между (X, y)
# X — Входные данные, т.е. данные на основе которых мы будем делать прогноз
# y — Выходные данные, т.е. то что мы предсказать

y = bitcoin.target # Только колонка target
X = bitcoin.drop("target", axis=1) # Берем все, кроме колонки target

# Тренировочная (обучающая) выборка = Train Set, тренируем модель, Учебник (X_train, y_train)
# Тестовая (проверочная) выборка = Test Set, проверяем модель, Экзамен (X_test, y_test)

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33)

from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import LinearRegression
from sklearn.metrics import max_error, mean_absolute_error, r2_score

model = LinearRegression()  #  Создаем
model.fit(X_train, y_train)  #  Обучаю

# Экзамен
y_pred = model.predict(X_test)
print("MAE", mean_absolute_error(y_pred, y_test))
print("Max Error", max_error(y_pred, y_test))
print("R2", r2_score(y_pred, y_test))

model = RandomForestRegressor()  #  Создаем
model.fit(X_train, y_train)  #  Обучаю

# Экзамен
y_pred = model.predict(X_test)
print("MAE", mean_absolute_error(y_pred, y_test))
print("Max Error", max_error(y_pred, y_test))
print("R2", r2_score(y_pred, y_test))